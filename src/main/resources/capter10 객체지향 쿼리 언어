객체지행 쿼리
=> 복잡한 쿼리문이 필요할 때가 있음
=> ORM은 테이블베이스 테이블이 아닌 엔티티 객체를 대상으로 개발

JPQL
=> 엔티티 객체를 조회하는 객체지향 쿼리
=> 특정 데이터베이승 의존하지 않음

- 대소문자를 구분하지 않음
- 엔티티명으로 접근
- 별칭 필수

TypeQuery: 반환티입 명확하게 지정 할 수 있을시 사용(select 할 것이 타입이 하나일 때)
Query : 반환타입 명확하게 지정 못할 시 사용(select 할 것이 타입이 여러개일 때)

조인
- 내부 조인
- 외부 조인
- 컬렉션 조인
- 세타 조인

- !페치 조인
=> 페치 조인은 별칭을 사용 할 수 없다.
=> 지연 로딩이 되지 않는다.
=> 팀과 회원이 있을 때 회원 엔티티가 영속성 컨텍스트에서 분리되어 준영속 상태가 되어도 연관된 팀 조회가 가능하다.


왜 즉시로딩을 사용하지 않고 지연로딩과 페치조인을 사용하는가?
=> 즉시로딩을 사용하면 회원 컬렉션을 즉시 로딩하기 위해 쿼리를 한 번 더 실행한다.
=> 페치조인을 사용하면 SQL 한번으로 연관된 엔티티들을 함께 조회 할 수 있다

페치 조인을 상ㅇ하면 연관된 엔티티를 뭐리 시점에 조회함으로 지연로딩이 발생하지 않음으로 준영속 상태에서도
객체 그래프를 탐색할 수 있다.

페치조인은 객체 그래프를 유지할 때 사용하면 효과적이고, 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 한다면
억지로 체피 조인을 사용학기 보다는 여러 테이블에서 필요한 필드들만 조회해서 DTO로 반환하는 것이 더 효과적


경로 표현식
1, 상태 필드 : 단순히 값을 저장하기 위한 필드
2, 연관 필드 : 연관관계를 위한 필드, 임베디드 타입 포함
    - 단일 값 연관필드 : 다대일, 일대일
    - 컬렉션 값 연관 필드 : 일대다, 다대다, 대상이 컬렉션

명시적 조인: join을 직접 적어주는 것
묵시적 조인: 경로 표현식에 의해 묵시적으로 조인이 일어나는 것

묵시적 조인 시 주의사항
- 항상 내부 조인이다
- 컬렉션은 경로 탐색의 끝이다
- 경로 탐색은 주오 SELECT , WHERE절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM절에 영향을 준다.

동적쿼리 : JPQL을 문자로 완성해서 직접 넘기는 것
정적쿼리: 미리 정의한 쿼리에 이름을 부여해서 필요할 때 사용(Named 쿼리)

import static : 정적 메소드나 정적 멤버 변수에 바로 접근히 가능하도록


Criteria
=> JPQL을 생성하는 빌더 클래스
=> 문자가 아닌 query.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성 할 수 있음
=> 문자 오타를 방지 할 수 있음
=> 컴파일 시점에 오류를 발견할 수 있음
=> IDE자동완성 기능 지원
=> 동적 쿼리를 작성하기 편함

QueryDSL
=> 기본 Q 생성
(쿼리 타입은 사용하기 편리하도록 기본 인스턴스를 보관하고 있다, 같은 엔티티를 조인하거나 같은 엔티티를 서브쿼리에 사용하면
같은 별칭이 사용되므로 별칭을 직업 지정해서 사용도 가능하다)
=> 검색조건
<from, where, orderBy, uniqueResult, singlResult, list>

!!주의 할 점
query객체 사용시 엔티티 매니저 생성을 해 주지 안으면 이전 쿼리 결과에 중첩적으로 결과를 담아 온다.

쿼리 결과가 엔티티가 아닌 특정 객체로 받고 싶으면 빈 생성 기능을 사용한다.
- 프로퍼티 접근
- 필드 직접 접근
- 생성자 사용

벌크 연산
=> 여러건을 한 번에 수정하거나 삭제하는 벌크연산을 사용(수 백개 이상의 엔티티를 처리 할 시)
=> (주의)벌크 연산 시 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리
    - em.refresh(엔티티) 사용
    - 벌크 연산 먼저 실행
    - 벌크 연산 수행 후 영속성 컨텍스트 초기화

영속성 컨텍스트와 JPQL
=> JPQL로 엔티티를 조회하면 영소겅 컨텍스트에서 관리되지만 엔티티가 아니면 영속성 컨텍스트에서 관리되지 않음
=> JPQL사용시 이미 영속성 컨텍스트에 존재한다면 디비로 가지 않음
<디비에서 가져 온 다음 영속성 컨텍스트에 식별자 기준으로 있다면 버림 => 수정중인 데이터가 사라질 수 있으므로>

em.find 같은 경우 영속성 컨텍스트에서 엔티티를 먼저 찾고 없으면 데이터베이스를 조회하지만 JPQL을 사용하면 데이터베이스를 먼저 조회한다.
(데이터베이스를 먼저 조회하고 엔티티가 있다면 결과를 버림)
