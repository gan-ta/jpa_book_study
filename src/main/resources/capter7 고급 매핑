상속 관계 매핑
1, 조인 전략
    장점
    - 테이블이 정구화됨
    - 외래키 참조 무결성 제약조건 활용가능
    - 저장공간 효율적으로 사용 가능
    단점
    - 조회할 떄 조인이 많이 사용됨으로 성능 저하
    - 조회 쿼리가 복잡
    - 데이터를 등록할 때 insert sql을 두 번 실행한다.
2, 단일 테이블 전략
    장점
    - 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다
    - 조회 쿼리가 단순
    단점
    - 자식 엔티티가 매핑한 컬럼은 모두 null을 허용
    - 단일 테이블에 모든 것을 저장함으로 테이블이 커져 조회 성능이 느릴 수 있음 =
    특징
    - 구분 컬럼을 꼭 사용해야 한다(@DiscriminatorColumn)
    - 지정하지 않으면 기본으로 엔티티 이름을 사용
3, 구현 클래스마다 테이블 전략
    장점
    - 서브 타입 구분해서 처리 할 때 효과적
    - not null 제약조건 사용 가능
    단점
    - 여러 자식 테이블 함께 조회할 깨 성능이 으림
    - 자식 테이블을 통합해서 쿼리하기 어려움
    특징
    - 구분 컬럼 사용하지 않음
    (춴하지 앟ㄴ음으로 조인이나 단일 테이블 전략을 고려)

@MappedSupperclass
=> 부모 클래스는 테이블과 매핑하지 많고 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶을 때 사용
=> 재 정의 하고 싶으면 @AttributesOverrides(매핑 정보 재정의), @AssociationOverrides(연관관계 재 정의)사용
=> 추상클래스로 만드는 것을 권장, 영속성 컨텍스트에서 직접적인 사용 불가능(엔티티가 아니기 때문에)
<진정한 상속매핑의 개념은 아님 >

식별관계 vs 비식별관계
=> 외래키가 기본기인가 아닌가?

필수적 비식별 관계 : 외래 키에 null을 허용하지 않음
선택적 비식별 관계 : 외래 키에 null을 허용함
(최근에는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별 관계)

복합키 지원 방식 2가지
1, @IdClass
    - 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다
    - Serializable 인터페이스를 구현해야 한다
    - equals, hashCode 구현해야 한다
    - 기본 생성자가 있어야 한다
    - 식별자 클래스는 public이어야 한다
2, @EmbeddedId
    -좀 더 객체지향적인 방법
    -Serializable 인터페이스 구현해야 한다
    - 기본 생성자가 있어야 한다
    - 식별자 클래스는 public이어야 한다


식별, 비식별 관계의 장단점

식별관계 보다는 비식별 관계를 선호
1, 자식의 키가 많아짐
2, 식별관걔응 2개 이상의 컬럼을 합해서 복합 기본키를 만들어야 하는 경우가 많음
3, 식별관계시 기본 키로 비즈니스 의미가 있는 자연 키 컬럼을 조합하는 경우가 많음
   (비즈니스 요구사항은 시간이 지나면 변하는 걍우가 많음으로 키로 사용하는 것을 추천하지 않음)
4, 테이블 구조가 유연하지 못함

객체 관계 매핑 관점에서 비식별 선호
1, 컬럼이 하나인 기본 키를 매핑하는 것보다 많은 노력이 필요
2, @GenerateValue처럼 대리 키를 생성하기 위한 편리한 방법이 있음

식별관계의 장점
1, 하위 테이블만으로 검색을 완료 할 수 있음

추천방법
=> 비식별 관계를 사용하고 기본키는 Long타입의 대리 키를 사용
=> 선택적 비식별 관계보다는 필수적 비식별 관계를 사용하는 것이 좋다.(null을 허용하게 되면 조인시 외부 조인을 사용해야 한다.)
ex) 학생솨 사물함

조인 컬럼과 조인 테이블
=> 조인 테이블은 추가적으로 테이블 생성을 해야 함으로 조인 컬럼을 사용하고 필요할 시에는 조인 테이블을 사용하자
조인 컬럼 => @JoinColumn
조인 테이블 => @JoinTable
조인 테이블은 일단 비 추천이고 다대다 같은 경우 새로 엔티티를 만들어서 추가적으로 칼럼을 추가 할 일이 많음으로
사실상 조인 테이블을 쓸 일은 그리 많지는 않을 것이다.



