*엔티티 매니저 팩토리
=> persistence.xml에 있는 정보를 바탕으로 만들어짐

엔티티 메니저를 팩토리에서 생성을 하면 비용이 거의 들지 않는다
단, 팩토리를 만드는 비용은 상당히 크다
=> 한개만 만들어서 애플리케이션 전체에서 공유를 함
=> 여러 스레드가 동시에 접근해도 된다
=> (주의) 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생함으로 스레드 간에 공유를 절대 해서는 안됨

엔티티 매니저 팩토리를 생성 할 때 보통 커넥션 풀도 같이 만듬

영속성 컨텍스트
=> 엔티티를 영구 저장하는 환경
=> persist() 메소드는 엔티티 매니저를 사용ㅎ해서 외원 엔티티를 영속성 컨텍스트에 저장함
=> 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어 진다(주의 할 점은 엔티티 매니저 마다 영속성 컨텍스트가 별도로 존대하기 때문에
혼동되게 사용하면 원치 않은 결과가 나올 수 있다.)

엔티티의 생명주기
비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태<아직 저장이 되지 않은 상태>
영속: 영속성 컨텍스트에 저장된 상태<persist()>
준영속: 영속성 턴텍스트에 저장되었다가 분리된 상태<detach() : 분리, close() : 영속성 컨텍스트 닫음, clear() : 영속성 컨텍스트 초기화>
삭제: 삭제된 상태<remove()>

영속성 컨텍스트 특징
1, 식별자와 값을 반드시 가져야 함(@Id)
2, 트렌젝션
    - 커밋을 하게 되면 flush가 발생이 되는데 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 저장
3, 장점
    - 1차 캐시
    - 동일성 보장(1차 캐시에서 객체 꺼내오기 때문)
        - 추가
            동일성: 실제 인스턴스가 같다
            동등성: 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다.
    - 트랜젝션을 지원하는 쓰기 지연
    - 변경 감지(Dirty Check)(이것 덕분에 따로 update를 안해줘도 자동으로 감지하고 update쿼리를 생성해줌)
        -이때, update문은 모든 컬럼에서 발생을 하게 되는데 일부 컬럼만 바꿔주기 위해서는 @DynamicUpdate 어노테이션을 활용한다.
       - 하지만, 모든 컬럼을 변경하도록 해 줌으로써 장점이 있다.(pg 105)
            1,로딩 시점에 수정 쿼리 미리 생성해두고 재사용 가능(수정 쿼리가 같으므로)
            2,DB에 동일한 쿼리 보내면 DB는 이전에 한번 파싱된 쿼리를 재사용 할 수 있다.
            결론은 필드가 많거나 저장되는 내용이 너무 크면 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성하는 전략을 사용하자.
            <보통 컬럼이 30개 이상일 때 DynamicUpdate가 수정 쿼리더 더 빠르다>
       -영속성 컨텍스트가 관리하는 영속 상태의 엔티티에서만 적용됨

    - 지연 로딩

*플러시
=> 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다
호출시점 3가지
1, 직접호출
2, 트렌젝션 커밋 시
3, JPQL 쿼리 실행

엔티티 매니저에 플러시 모드를 직접 지정하려면 jaavax.persistence.FlushModeType을 사용하면 된다.
FlushModeType.AUTO 커밋히나 쿼리를 실행할 때 플러시
FlushModeType.COMMIT :커밋할 때만 플러시
ex) em.setFlushMode(FlushModeType.COMMIT)

(주의) 플러시라는 이름으로 인해 영속성 컨텍스트에 보관된 엔티티를 지운다고 생각하면 안됨.
      영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는것이 플러시

준영속 <영속 상태였다가 더는 영속성 컨텍스트가 관리하지 않는 상태>
detached() :  merge()로 다시 관리 상태로 만들 수 있음<정확히는 해당 엔티티가 아니라 새로운 영속 상태의 엔티티가 생성> ,해당 엔티티만 준영속
clear() : 영속성 컨텍스트의 모든 엔티티를 준영속 상태
close(): 영속성 컨텍스트를 종료하면 영속 상태의 엔티티가 모두 준영속 상태가 됨

준영속 상태 특징
1, 비영속 상태에 가까움
2, 식별자 값을 가지고 있다(비영속과의 차이, 준영속은 이미 한번 영속 상태였기 때문에 반드시 식별자 값을 가지고 있다.)
3, 지연 로딩을 할 수 없다(프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법)

merge() 작동 방식
1, 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티 조회
2, 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고 1차 캐시에 저장
3, 조회한 영속 엔티티에 member 엔티티 값을 채원 넣는다.
4, mergeMember를 반환



